{"version":3,"file":null,"sources":["../src/cleaners/normalise-cleaner.js","../src/cleaners/contractions-cleaner.js","../src/cleaners/salutations-cleaner.js","../src/cleaners/politeness-cleaner.js","../src/cleaners/questions-cleaner.js","../src/parsers/chrono/chrono.js","../src/parsers/time-parser.js","../src/parsers/users-parser.js","../src/parsers/action-parser.js","../src/refiners/confirmations/reminder-confirmation.js","../src/refiners/reminder-refiner.js","../src/refiners/confirmations/query-confirmation.js","../src/refiners/query-refiner.js","../src/intent-parser.js"],"sourcesContent":["export default class NormaliseCleaner {\n  clean(obj = { raw: '' }) {\n    const text = obj.raw\n    // Normalise whitespace to space.\n      .replace(/\\s+/g, ' ')\n      .trim();\n\n    // Let's use the normalised text for the rest of the processing.\n    obj.text = text;\n    obj.cleaned = text;\n\n    return Promise.resolve(obj);\n  }\n}\n","export default class ContractionsCleaner {\n  clean(obj = { cleaned: '' }) {\n    const cleaned = obj.cleaned\n    // Unambiguous cases.\n      .replace(/\\b(let)'s\\b/ig, '$1 us') // Keep the case.\n      .replace(/'s (been|got|gotten)\\b/ig, ' has $1')\n      .replace(/'s (being|going)\\b/ig, ' is $1')\n      .replace(/'d (like|love)\\b/ig, ' would $1')\n\n      // Irregular negations.\n      .replace(/\\b(should)n't've\\b/ig, '$1 not have')\n      .replace(/\\b(would)n't've\\b/ig, '$1 not have')\n      .replace(/\\b(could)n't've\\b/ig, '$1 not have')\n      .replace(/\\b(s)han't\\b/ig, '$1hall not') // Keep the first letter case.\n      .replace(/\\b(w)on't\\b/ig, '$1ill not')\n      .replace(/\\b(c)an't\\b/ig, '$1annot')\n\n      // Regular contractions.\n      .replace(new RegExp('\\\\b(' +\n        'am|are|could|did|do|does|had|has|have|' +\n        'is|might|must|should|was|were|would' +\n        ')n\\'t\\\\b', 'ig'), '$1 not')\n      .replace(/\\b(g)onna\\b/ig, '$1oing to') // Keep the first letter case.\n      .replace(/\\b(w)anna\\b/ig, '$1ant to')\n      .replace(/'ll\\b/ig, ' will')\n      .replace(/'re\\b/ig, ' are')\n      .replace(/'ve\\b/ig, ' have')\n      .replace(/'m\\b/ig, ' am');\n\n    obj.cleaned = cleaned;\n\n    return Promise.resolve(obj);\n  }\n}\n","const PUNCTUATION = {\n  // @see http://www.unicode.org/cldr/charts/29/summary/en.html#4\n  en: '[-‐–—,;:!?.…\\'‘’\"“”()[\\\\]§@*/&#†‡′″]',\n  fr: '[-‐–—,;:!?.…’\"“”«»()[\\\\]§@*/&#†‡]',\n  ja: '[-‾_＿－‐—―〜・･,，、､;；:：!！?？.．‥…。｡＇‘’\"＂“”(（)）\\\\[［\\\\]］{｛}｝' +\n  '〈〉《》「｢」｣『』【】〔〕‖§¶@＠*＊/／\\\\＼&＆#＃%％‰†‡′″〃※]',\n};\n\nexport default class SalutationsCleaner {\n  clean(obj = { cleaned: '' }) {\n    const cleaned = obj.cleaned\n      .replace(\n        new RegExp(`^(?:Hello|Hey|Hi|Yo)${PUNCTUATION.en}* (.)`, 'i'),\n        // Capitalise the first letter.\n        (match, letter) => letter.toUpperCase()\n      );\n\n    obj.cleaned = cleaned;\n\n    return Promise.resolve(obj);\n  }\n}\n","// @todo Use a POS tagger and reorganise element in questions:\n// * \"Tell me where you are.\" => \"Where are you?\"\nexport default class PolitenessCleaner {\n  clean(obj = { cleaned: '' }) {\n    const cleaned = obj.cleaned\n      .replace(\n        new RegExp('^(?:' +\n          '|Could you please ' +\n          '|Please could you ' +\n          '|Could you ' +\n          '|Would you please ' +\n          '|Please would you ' +\n          '|Would you ' +\n          '|Will you please ' +\n          '|Please will you ' +\n          '|Will you ' +\n          '|Can you please ' +\n          '|Please can you ' +\n          '|Can you ' +\n          '|Please do ' +\n          '|Please ' +\n          ')?(.)', 'i'),\n        // Capitalise the first letter.\n        (match, letter) => letter.toUpperCase()\n      );\n\n    obj.cleaned = cleaned;\n\n    return Promise.resolve(obj);\n  }\n}\n","export default class QuestionsCleaner {\n  clean(obj = { cleaned: '' }) {\n    let cleaned = obj.cleaned\n      .replace(\n        new RegExp('^(?:Tell me ' +\n          '|Let me know ' +\n          '|Inform me ' +\n          '|I want to know ' +\n          ')wh(at|ere|en|o)\\\\b', 'i'),\n        'Wh$1'\n      );\n\n    if (cleaned !== obj.cleaned) {\n      if (cleaned.match(/^Wh(at|ere|en|o)\\b/i)) {\n        // Add question mark if it is a question.\n        cleaned = cleaned.replace(/\\.+$/, '?');\n      }\n    }\n\n    obj.cleaned = cleaned;\n\n    return Promise.resolve(obj);\n  }\n}\n","import chrono from 'chrono-node';\nimport chronoUtils from 'chrono-node/src/utils/EN';\n\n/**\n * Parse day periods according to CLDR.\n * @see http://www.unicode.org/cldr/charts/29/verify/dates/en.html\n */\nconst dayPeriodsParser = new chrono.Parser();\ndayPeriodsParser.pattern =\n  () => new RegExp('\\\\b(?:midnight|morning|in the morning|noon|afternoon|' +\n    'in the afternoon|evening|in the evening|night|at night)\\\\b', 'i');\ndayPeriodsParser.extract = (text, ref, match) => {\n  let hour;\n  let meridiem;\n\n  switch (match[0].toLowerCase()) {\n    case 'midnight':\n      hour = 0;\n      meridiem = 0;\n      break;\n    case 'morning':\n    case 'in the morning':\n      hour = 9;\n      meridiem = 0;\n      break;\n    case 'noon':\n      hour = 12;\n      meridiem = 1;\n      break;\n    case 'afternoon':\n    case 'in the afternoon':\n      hour = 15;\n      meridiem = 1;\n      break;\n    case 'evening':\n    case 'in the evening':\n      hour = 18;\n      meridiem = 1;\n      break;\n    case 'night':\n    case 'at night':\n      hour = 22;\n      meridiem = 1;\n      break;\n    default:\n      break;\n  }\n\n  return new chrono.ParsedResult({\n    ref,\n    text: match[0],\n    index: match.index,\n    start: {\n      hour,\n      meridiem,\n    },\n  });\n};\n\nconst currentMonthDayParser = Object.assign(\n  new chrono.Parser(),\n  {\n    pattern: () => new RegExp(\n      // eslint-disable-next-line prefer-template\n      '\\\\bthe (([0-9]{1,2})(?:st|nd|rd|th)?|' +\n      chronoUtils.ORDINAL_WORDS_PATTERN + ')\\\\b',\n      'i' // flag\n    ),\n    extract: (text, ref, match) => {\n      const stringMatch = match[1];\n      const numericalDay = match[2];\n      const day = numericalDay\n        ? Number(numericalDay)\n        : chronoUtils.ORDINAL_WORDS[stringMatch.toLowerCase()];\n      const currentDay = ref.getDate(); // TODO support timezones\n      const currentMonth = ref.getMonth();\n\n      const month = day >= currentDay ? currentMonth : currentMonth + 1;\n\n      return new chrono.ParsedResult({\n        ref,\n        text: match[0],\n        index: match.index,\n        start: {\n          // JS date have months between 0 and 11,\n          // while chrono expects a month between 1 and 12.\n          month: month + 1,\n          day,\n        },\n      });\n    },\n  }\n);\n\n\n/**\n * When the meridiem is not specified, set the time to after the current time.\n * `at 5 today` (current time is 3pm) => `5pm`.\n */\nconst forwardHoursRefiner = new chrono.Refiner();\nforwardHoursRefiner.refine = (text, results, opt = {}) => {\n  if (opt.forwardHoursOnly !== true) {\n    return results;\n  }\n\n  // If the date is today and there is no AM/PM (meridiem) specified,\n  // let all the time be after the current time.\n  results.forEach((result) => {\n    changeDate(result.start, result.ref);\n    if (result.end) {\n      changeDate(result.end, result.ref);\n    }\n  });\n\n  return results;\n\n  function changeDate(component, ref) {\n    if (!component.isCertain('meridiem')\n      && component.moment(ref).isSame(component, 'day')\n      && component.get('hour') <= ref.getHours()) {\n      component.assign('meridiem', 1);\n      component.assign('hour', component.get('hour') + 12);\n    }\n  }\n};\n\nconst customChrono = new chrono.Chrono(chrono.options.casualOption());\ncustomChrono.parsers.push(dayPeriodsParser);\ncustomChrono.parsers.push(currentMonthDayParser);\ncustomChrono.refiners.push(forwardHoursRefiner);\n\nexport default {\n  parse: (phrase) => customChrono.parse(phrase, null, {\n    forwardDate: true,\n    forwardDatesOnly: true,\n    forwardHoursOnly: true,\n  }),\n};\n","import chrono from './chrono/chrono';\n\nconst p = Object.freeze({\n  normaliseTimes: Symbol('normaliseTimes'),\n});\n\n/**\n * Current bugs about time extraction from the original text:\n *\n * * When a time frame is set, the \"from\" should be extracted too.\n *   e.g. \"I'm busy from Mon to Tue\" => \"I'm busy from\"\n *\n * * When multiple dates are specified, they should all be removed.\n *   e.g. \"I'm busy on Wed and Thurs\" =>\n *        [\"I'm busy on and Thurs\", \"I'm busy on Wed and\"]\n */\nexport default class TimeParser {\n  parse(obj = { cleaned: '' }) {\n    const text = this[p.normaliseTimes](obj.cleaned);\n    const dates = chrono.parse(text);\n\n    if (!dates.length) {\n      obj.time = null;\n      return Promise.resolve(obj);\n    }\n\n    const time = dates.map((date) => {\n      const start = date.start ? Number(date.start.date()) : null;\n      const end = date.end ? Number(date.end.date()) : null;\n      const extractedText = date.text;\n      let beforeText = text.substr(0, date.index).trim();\n      const afterText = text.substr(date.index + extractedText.length).trim();\n\n      // temporary fix for https://github.com/wanasit/chrono/issues/152\n      if (/\\b(?:on|by)$/.test(beforeText)) {\n        beforeText = beforeText.slice(0, -3);\n      }\n\n      const processedText = `${beforeText} ${afterText}`;\n\n      return { start, end, extractedText, processedText };\n    });\n\n    obj.time = time;\n\n    return Promise.resolve(obj);\n  }\n\n  [p.normaliseTimes](text = '') {\n    // The Web Speech API returns PM hours as `p.m.`.\n    return text\n      .replace(/([0-9]) ?p\\.m\\./gi, '$1 PM')\n      .replace(/([0-9]) ?a\\.m\\./gi, '$1 AM');\n  }\n}\n","const PATTERNS = {\n  en: {\n    patterns: [\n      /^Remind (.+?) (?:to|at|on|by|that|about)\\b/i,\n      /^Where (?:am|are|is) (.+?) (?:at|on|by)\\b/i,\n      /^Where (?:am|are|is) (.+?) supposed to\\b/i,\n      /^Where should (.+?) go\\b/i,\n      /^What (?:am|are|is) (.+?) doing\\b/i,\n      /^What (?:am|are|is) (.+?) supposed to\\b/i,\n      /^What should (.+?) do\\b/i,\n      /^What (?:do|does) (.+?) do\\b/i,\n      /^What is (.+?)(?:'s)? (?:schedule|planning|calendar|agenda)\\b/i,\n      /([^ ]+ (?:and|&) [^ ]+)/i, // @todo Improve with more patterns.\n    ],\n    // @see http://www.unicode.org/cldr/charts/29/summary/en.html#6402\n    listBreaker: /,? (?:and|&) |, /gi,\n  },\n\n  fr: {\n    patterns: [\n      /Rappelle (.+?) de (?:.+)/i,\n      /Rappelle (.+?) d'(?:.+)/i,\n      /Rappelle-(.+?) de (?:.+)/i,\n      /Rappelle-(.+?) d'(?:.+)/i,\n    ],\n    listBreaker: /,? (?:et|&) |, /gi,\n  },\n\n  ja: {\n    patterns: [\n      /(?:.+)を(.+)に思い出させて/i,\n      /(.+)に(?:.+)を思い出させて/i,\n      /(.+)は(?:.+)と言うリマインダーを作成して/i,\n    ],\n    listBreaker: /、/gu,\n  },\n};\n\nconst p = Object.freeze({\n  users: Symbol('users'),\n  normalise: Symbol('normalise'),\n});\n\n// @todo Import and use the list of users when multiusers db is ready.\nexport default class UsersParser {\n  constructor(users = []) {\n    this[p.users] = users;\n  }\n\n  parse(obj = { cleaned: '' }) {\n    const text = obj.cleaned;\n    let users = null;\n\n    PATTERNS.en.patterns.some((pattern) => {\n      const match = pattern.exec(text);\n\n      if (!match) {\n        return false;\n      }\n\n      users = this.parseUsers(match[1]);\n      return !!users.length;\n    });\n\n    obj.recipients = users;\n\n    return Promise.resolve(obj);\n  }\n\n  parseUsers(string = '') {\n    return string\n      .split(PATTERNS.en.listBreaker)\n      .map((user) => user.trim())\n      .filter((user) => !!user);\n  }\n}\n","const PATTERNS = {\n  en: {\n    patterns: [\n      /Remind (?:.+?) (?:to|at|on|by|that|about) (.+)/i,\n      /Remind (?:.+?) that (?:it|there) is (.+)/i,\n    ],\n    // @see http://www.unicode.org/cldr/charts/29/summary/en.html#4\n    punctuation: /[-‐–—,;:!?.…'‘’\"“”()[\\]§@*/&#†‡′″]+$/,\n  },\n\n  fr: {\n    patterns: [\n      /Rappelle (?:.+?) de (.+)/i,\n      /Rappelle (?:.+?) d'(.+)/i,\n      /Rappelle-(?:.+?) de (.+)/i,\n      /Rappelle-(?:.+?) d'(.+)/i,\n    ],\n    punctuation: /[-‐–—,;:!?.…’\"“”«»()[\\]§@*/&#†‡]+$/,\n  },\n\n  ja: {\n    patterns: [\n      /(.+)を(?:.+)に思い出させて/i,\n      /(?:.+)に(.+)を思い出させて/i,\n      /(?:.+)は(.+)と言うリマインダーを作成して/i,\n    ],\n    // eslint-disable-next-line max-len\n    punctuation: /[-‾_＿－‐—―〜・･,，、､;；:：!！?？.．‥…。｡＇‘’\"＂“”(（)）[［\\]］{｛}｝〈〉《》「｢」｣『』【】〔〕‖§¶@＠*＊/／\\\\＼&＆#＃%％‰†‡′″〃※]+$/u,\n  },\n};\n\nconst p = Object.freeze({\n  normalise: Symbol('normalise'),\n  parseNoDates: Symbol('parseNoDates'),\n  parseMultipleDates: Symbol('parseMultipleDates'),\n});\n\nexport default class ActionParser {\n  parse(obj = { cleaned: '', time: [] }) {\n    let action = null;\n\n    if (!obj.time || !obj.time.length) {\n      // We use the original phrase.\n      const text = this[p.normalise](obj.cleaned);\n      action = this[p.parseNoDates](text);\n    } else if (obj.time.length === 1) {\n      // We use the original phrase with the time extracted out.\n      const text = this[p.normalise](obj.time[0].processedText);\n      action = this[p.parseNoDates](text);\n    } else if (obj.time.length > 1) {\n      const text = this[p.normalise](obj.cleaned);\n      action = this[p.parseMultipleDates](text);\n    }\n\n    obj.action = action;\n\n    return Promise.resolve(obj);\n  }\n\n  [p.normalise](string = '') {\n    return string\n    // Strip punctuations.\n      .replace(PATTERNS.en.punctuation, '')\n      .trim();\n  }\n\n  /**\n   * Extract an action from a sentence that has no time references.\n   *\n   * @param {string} text\n   * @return {string}\n   */\n  [p.parseNoDates](text = '') {\n    let action = null;\n\n    PATTERNS.en.patterns.some((pattern) => {\n      const match = pattern.exec(text);\n\n      if (!match) {\n        return false;\n      }\n\n      action = match[1];\n      return true;\n    });\n\n    return action;\n  }\n\n  [p.parseMultipleDates]() {\n    // @todo Implement me.\n    console.error('Parsing action with multiple time references is not ' +\n      'implemented yet.');\n    return null;\n  }\n}\n","/* global TwitterCldr, TwitterCldrDataBundle */\n\nimport moment from 'moment';\n\n/*\n * @todo:\n *   * @see http://www.unicode.org/cldr/charts/29/verify/dates/en.html\n *     for formatting the time of the day.\n */\n\nconst p = Object.freeze({\n  // Properties\n  listFormatter: Symbol('listFormatter'),\n\n  // Methods\n  getLocalised: Symbol('getLocalised'),\n  formatUser: Symbol('formatUser'),\n  formatAction: Symbol('formatAction'),\n  formatTime: Symbol('formatTime'),\n  isToday: Symbol('isToday'),\n  isTomorrow: Symbol('isTomorrow'),\n  isThisMonth: Symbol('isThisMonth'),\n  formatHoursAndMinutes: Symbol('formatHoursAndMinutes'),\n});\n\nconst DEFAULT_LOCALE = 'en';\nconst PATTERNS = {\n  en: {\n    template: `OK, I'll remind [users] [action] [time].`,\n    formatUser: (user) => user\n      .replace(/\\bme\\b/gi, 'you')\n      .replace(/\\bI am\\b/gi, 'you are')\n      .replace(/\\bI have\\b/gi, 'you have')\n      .replace(/\\bI will\\b/gi, 'you will')\n      .replace(/\\bI\\b/gi, 'you')\n      .replace(/\\bmy\\b/gi, 'your')\n      .replace(/\\bmine\\b/gi, 'yours'),\n  },\n  fr: {\n    template: `OK, je rappelerai [users] [action] [time].`,\n    formatUser: (user) => user,\n  },\n  ja: {\n    template: `承知しました。[time][users]に[action]をリマインドします。`,\n    formatUser: (user) => user,\n  },\n};\n\nexport default class ReminderConfirmation {\n  constructor(locale = DEFAULT_LOCALE) {\n    this.locale = locale;\n\n    if (typeof TwitterCldr === 'undefined') {\n      this[p.listFormatter] = {\n        format: (a) => a.join(' and '),\n      };\n    } else {\n      TwitterCldr.set_data(TwitterCldrDataBundle);\n      this[p.listFormatter] = new TwitterCldr.ListFormatter();\n    }\n  }\n\n  /**\n   * Generate a phrase to be spoken to confirm a reminder.\n   *\n   * @param {Object} reminder\n   * @return {string}\n   */\n  confirm(reminder) {\n    const template = this[p.getLocalised]('template');\n    const data = {\n      users: this[p.formatUser](reminder),\n      action: this[p.formatAction](reminder),\n      time: this[p.formatTime](reminder),\n    };\n\n    return template.replace(/\\[([^\\]]+)\\]/g, (match, placeholder) => {\n      return data[placeholder];\n    });\n  }\n\n  /**\n   * Given a property of the PATTERNS object, returns the one matching the\n   * current locale or the default one if non existing.\n   *\n   * @param {string} prop\n   * @returns {*}\n   */\n  [p.getLocalised](prop) {\n    let locale = this.locale;\n    if (!PATTERNS[this.locale] || !PATTERNS[this.locale][prop]) {\n      locale = DEFAULT_LOCALE;\n    }\n\n    return PATTERNS[locale][prop];\n  }\n\n  [p.formatUser]({ recipients }) {\n    const formatUser = this[p.getLocalised]('formatUser');\n    const formattedUsers = recipients.map(formatUser);\n    return this[p.listFormatter].format(formattedUsers);\n  }\n\n  [p.formatAction]({ action, cleaned }) {\n    const formatUser = this[p.getLocalised]('formatUser');\n    const formattedAction = formatUser(action);\n\n    const PATTERN1 = new RegExp(`\\\\bthat ${action}`, 'i');\n    const PATTERN2 = new RegExp(`\\\\bit is ${action}`, 'i');\n    const PATTERN3 = new RegExp(`\\\\bthere is ${action}`, 'i');\n    const PATTERN4 = new RegExp(`\\\\babout ${action}`, 'i');\n\n    if (PATTERN1.test(cleaned)) {\n      return `that ${formattedAction}`;\n    } else if (PATTERN2.test(cleaned)) {\n      return `that it is ${formattedAction}`;\n    } else if (PATTERN3.test(cleaned)) {\n      return `that there is ${formattedAction}`;\n    } else if (PATTERN4.test(cleaned)) {\n      return `about ${formattedAction}`;\n    }\n\n    return `to ${formattedAction}`;\n  }\n\n  [p.formatTime]({ due }) {\n    if (this[p.isToday](due)) {\n      const hour = this[p.formatHoursAndMinutes](due);\n      return `at ${hour} today`;\n    } else if (this[p.isTomorrow](due)) {\n      const hour = this[p.formatHoursAndMinutes](due);\n      return `at ${hour} tomorrow`;\n      // @todo Add a pattern here with the weekday if within 7 days.\n    } else if (this[p.isThisMonth](due)) {\n      return moment(due).format('[on the] Do');\n    }\n\n    return moment(due).format('[on] MMMM [the] Do');\n  }\n\n  [p.isToday](date) {\n    const today = moment().startOf('day');\n    const tomorrow = moment().add(1, 'day').startOf('day');\n    return moment(date).isBetween(today, tomorrow);\n  }\n\n  [p.isTomorrow](date) {\n    const tomorrow = moment().add(1, 'day').startOf('day');\n    const in2days = moment().add(2, 'day').startOf('day');\n    return moment(date).isBetween(tomorrow, in2days);\n  }\n\n  [p.isThisMonth](date) {\n    const thisMonth = moment().startOf('month');\n    const nextMonth = moment().add(1, 'month').startOf('month');\n    return moment(date).isBetween(thisMonth, nextMonth);\n  }\n\n  /**\n   * Return a string from a date suitable for speech synthesis.\n   *\n   * @param {Date} date\n   * @return {string}\n   */\n  [p.formatHoursAndMinutes](date) {\n    date = moment(date);\n    let format;\n\n    if (date.minute() === 0) {\n      format = date.format('h A'); // 7 PM\n    } else if (date.minute() === 15) {\n      format = date.format('[quarter past] h A');\n    } else if (date.minute() === 30) {\n      format = date.format('[half past] h A');\n    } else if (date.minute() === 45) {\n      const nextHour = date.add(1, 'hour');\n      format = nextHour.format('[quarter to] h A');\n    } else {\n      format = date.format('h:m A'); // 6:24 AM\n    }\n\n    // Some speech synthesisers pronounce \"AM\" as in \"ham\" (not \"A. M.\").\n    return format\n      .replace(/([0-9]) ?AM$/gi, '$1 A.M.')\n      .replace(/([0-9]) ?PM$/gi, '$1 P.M.');\n  }\n}\n","import ReminderConfirmation from './confirmations/reminder-confirmation';\n\nconst p = Object.freeze({\n  reminderConfirmation: Symbol('reminderConfirmation'),\n});\n\nexport default class ReminderRefiner {\n  constructor() {\n    this[p.reminderConfirmation] = new ReminderConfirmation();\n  }\n\n  /**\n   * A reminder is an intent that:\n   *  * Starts with \"Remind\"\n   *  * Has a single time reference\n   *  * Has at least 1 user\n   *  * Has an action\n   *\n   * @param {Object} obj\n   * @returns {Promise}\n   */\n  refine(obj = {}) {\n    const hasTime = obj.time !== null\n      && obj.time.length === 1\n      && obj.time[0].start !== null\n      && obj.time[0].end === null;\n    const hasUsers = obj.recipients !== null\n      && obj.recipients.length > 0;\n    const hasAction = obj.action !== null;\n\n    if (obj.cleaned.toLowerCase().startsWith('remind')\n      && hasTime\n      && hasUsers\n      && hasAction) {\n      obj.due = obj.time[0].start;\n      obj.confirmation = this[p.reminderConfirmation].confirm(obj);\n      obj.intent = 'reminder';\n    }\n\n    return Promise.resolve(obj);\n  }\n}\n","/* global TwitterCldr, TwitterCldrDataBundle */\n\nimport moment from 'moment';\n\nconst p = Object.freeze({\n  // Properties\n  time: Symbol('time'),\n  users: Symbol('users'),\n  listFormatter: Symbol('listFormatter'),\n\n  // Methods\n  formatTime: Symbol('formatTime'),\n  isToday: Symbol('isToday'),\n  isTomorrow: Symbol('isTomorrow'),\n  isThisMonth: Symbol('isThisMonth'),\n  formatHoursAndMinutes: Symbol('formatHoursAndMinutes'),\n});\n\nconst PATTERNS = {\n  en: {\n    formatUser: (user) => user\n      .replace(/\\bme\\b/gi, 'you')\n      .replace(/\\bI am\\b/gi, 'you are')\n      .replace(/\\bI have\\b/gi, 'you have')\n      .replace(/\\bI will\\b/gi, 'you will')\n      .replace(/\\bI\\b/gi, 'you')\n      .replace(/\\bmy\\b/gi, 'your')\n      .replace(/\\bmine\\b/gi, 'yours'),\n  },\n  fr: {\n    formatUser: (user) => user,\n  },\n  ja: {\n    formatUser: (user) => user,\n  },\n};\n\nexport default class QueryConfirmation {\n  constructor({ due, recipients }) {\n    if (typeof TwitterCldr === 'undefined') {\n      this[p.listFormatter] = {\n        format: (a) => a.join(' and '),\n      };\n    } else {\n      TwitterCldr.set_data(TwitterCldrDataBundle);\n      this[p.listFormatter] = new TwitterCldr.ListFormatter();\n    }\n\n    this[p.time] = due;\n    this[p.users] = recipients;\n  }\n\n  confirm(reminder) {\n    // We use the users from the original query rather than the found reminder.\n    const users = this[p.formatUser](this[p.users]);\n\n    if (!reminder) {\n      const time = this[p.formatTime]({ due: this[p.time] });\n      return `I can't find anything scheduled for ${users} ${time}.`;\n    }\n\n    const action = reminder.action;\n    const time = this[p.formatTime](reminder);\n\n    if (users === 'you' || this[p.users].length >= 1) {\n      return `${time}, ${users} have the following activity: \"${action}\".`;\n    }\n\n    return `${time}, ${users} has the following activity: \"${action}\".`;\n  }\n\n  [p.formatUser](users) {\n    const formattedUsers = users.map(PATTERNS.en.formatUser);\n    return this[p.listFormatter].format(formattedUsers);\n  }\n\n  [p.formatTime]({ due }) {\n    const hour = this[p.formatHoursAndMinutes](due);\n\n    if (this[p.isToday](due)) {\n      return `at ${hour} today`;\n    } else if (this[p.isTomorrow](due)) {\n      return `at ${hour} tomorrow`;\n      // @todo Add a pattern here with the weekday if within 7 days.\n    } else if (this[p.isThisMonth](due)) {\n      const day = moment(due).format('Do');\n      return `at ${hour} on the ${day}`;\n    }\n\n    const day = moment(due).format('MMMM [the] Do');\n    return `at ${hour} on ${day}`;\n  }\n\n  [p.isToday](date) {\n    const today = moment().startOf('day');\n    const tomorrow = moment().add(1, 'day').startOf('day');\n    return moment(date).isBetween(today, tomorrow);\n  }\n\n  [p.isTomorrow](date) {\n    const tomorrow = moment().add(1, 'day').startOf('day');\n    const in2days = moment().add(2, 'day').startOf('day');\n    return moment(date).isBetween(tomorrow, in2days);\n  }\n\n  [p.isThisMonth](date) {\n    const thisMonth = moment().startOf('month');\n    const nextMonth = moment().add(1, 'month').startOf('month');\n    return moment(date).isBetween(thisMonth, nextMonth);\n  }\n\n  /**\n   * Return a string from a date suitable for speech synthesis.\n   *\n   * @param {Date} date\n   * @return {string}\n   */\n  [p.formatHoursAndMinutes](date) {\n    date = moment(date);\n    let format;\n\n    if (date.minute() === 0) {\n      format = date.format('h A'); // 7 PM\n    } else if (date.minute() === 15) {\n      format = date.format('[quarter past] h A');\n    } else if (date.minute() === 30) {\n      format = date.format('[half past] h A');\n    } else if (date.minute() === 45) {\n      const nextHour = date.add(1, 'hour');\n      format = nextHour.format('[quarter to] h A');\n    } else {\n      format = date.format('h:m A'); // 6:24 AM\n    }\n\n    // Some speech synthesisers pronounce \"AM\" as in \"ham\" (not \"A. M.\").\n    return format\n      .replace(/([0-9]) ?AM$/gi, '$1 A.M.')\n      .replace(/([0-9]) ?PM$/gi, '$1 P.M.');\n  }\n}\n","import QueryConfirmation from './confirmations/query-confirmation';\n\nconst PATTERNS = {\n  en: {\n    formatUser: (user) => user\n      .replace(/\\bI\\b/gi, 'me')\n      .replace(/\\bmy\\b/gi, 'me')\n      .replace(/\\bmine\\b/gi, 'me'),\n  },\n  fr: {\n    formatUser: (user) => user,\n  },\n  ja: {\n    formatUser: (user) => user,\n  },\n};\n\n// @todo Handle the case where a time range is specified.\nexport default class QueryRefiner {\n  /**\n   * A query is an intent that:\n   *  * Looks like a question\n   *  * Has a single time reference\n   *  * Has at least 1 user\n   *  * Has no actions\n   *\n   * @param {Object} obj\n   * @returns {Promise}\n   */\n  refine(obj = {}) {\n    const hasTime = obj.time !== null\n      && obj.time.length === 1\n      && obj.time[0].start !== null\n      && obj.time[0].end === null;\n    const hasUsers = obj.recipients !== null\n      && obj.recipients.length > 0;\n    const hasNoActions = obj.action === null;\n\n    if (obj.cleaned.match(/^(?:What|Where|When)/i)\n      && hasTime\n      && hasUsers\n      && hasNoActions) {\n      const queryConfirmation = new QueryConfirmation({\n        due: obj.time[0].start,\n        recipients: obj.recipients,\n      });\n\n      obj.due = obj.time[0].start;\n      obj.recipients = obj.recipients.map(PATTERNS.en.formatUser);\n      obj.confirmation = queryConfirmation.confirm.bind(queryConfirmation);\n      obj.intent = 'query';\n    }\n\n    return Promise.resolve(obj);\n  }\n}\n","import NormaliseCleaner from './cleaners/normalise-cleaner';\nimport ContractionsCleaner from './cleaners/contractions-cleaner';\nimport SalutationsCleaner from './cleaners/salutations-cleaner';\nimport PolitenessCleaner from './cleaners/politeness-cleaner';\nimport QuestionsCleaner from './cleaners/questions-cleaner';\n\nimport TimeParser from './parsers/time-parser';\nimport UsersParser from './parsers/users-parser';\nimport ActionParser from './parsers/action-parser';\n\nimport ReminderRefiner from './refiners/reminder-refiner';\nimport QueryRefiner from './refiners/query-refiner';\n\nconst p = Object.freeze({\n  // Properties\n  cleaners: Symbol('cleaners'),\n  parsers: Symbol('parsers'),\n  refiners: Symbol('refiners'),\n});\n\nexport default class IntentParser {\n  constructor() {\n    this[p.cleaners] = [\n      new NormaliseCleaner(), // Always keep this one first.\n      new ContractionsCleaner(),\n      new SalutationsCleaner(),\n      new PolitenessCleaner(),\n      new QuestionsCleaner(), // Must go after PolitenessCleaner`\n    ];\n    this[p.parsers] = [\n      new TimeParser(),\n      new UsersParser(),\n      new ActionParser(),\n    ];\n    this[p.refiners] = [\n      new ReminderRefiner(),\n      new QueryRefiner(),\n    ];\n\n    // Add it to the global scope for debugging.\n    // eslint-disable-next-line no-new-func\n    const global = new Function('return this')();\n    global.intentParser = this;\n    // eslint-enable\n  }\n\n  parse(text = '') {\n    text = String(text);\n\n    const result = {\n      raw: text, // Leave this untouched for debugging purposes.\n      intent: null,\n    };\n\n    const cleaningPromises = this[p.cleaners]\n      .map((cleaner) => cleaner.clean.bind(cleaner));\n    const parsingPromises = this[p.parsers]\n      .map((parser) => parser.parse.bind(parser));\n    const refiningPromises = this[p.refiners]\n      .map((refiner) => refiner.refine.bind(refiner));\n\n    return new Promise((resolve, reject) => {\n      Promise.resolve(result)\n      // Cleaning phase.\n        .then((result) => cleaningPromises\n          .reduce((p, val) => p.then(val), Promise.resolve(result)))\n\n        // Parsing phase.\n        .then((result) => parsingPromises\n          .reduce((p, val) => p.then(val), Promise.resolve(result)))\n\n        // Refining phase.\n        .then((result) => refiningPromises\n          .reduce((p, val) => p.then(val), Promise.resolve(result))\n        )\n\n        // Final result.\n        .then((result) => {\n          if (result.intent === null) {\n            console.error('The intent could not be parsed:', result);\n            return reject(null);\n          }\n\n          return resolve(result);\n        });\n    });\n  }\n}\n"],"names":["NormaliseCleaner","clean","obj","raw","text","replace","trim","cleaned","Promise","resolve","ContractionsCleaner","RegExp","PUNCTUATION","SalutationsCleaner","en","match","letter","toUpperCase","PolitenessCleaner","QuestionsCleaner","dayPeriodsParser","chrono","Parser","pattern","extract","ref","hour","meridiem","toLowerCase","ParsedResult","index","currentMonthDayParser","Object","assign","chronoUtils","ORDINAL_WORDS_PATTERN","stringMatch","numericalDay","day","Number","ORDINAL_WORDS","currentDay","getDate","currentMonth","getMonth","month","forwardHoursRefiner","Refiner","refine","results","changeDate","component","isCertain","moment","isSame","get","getHours","opt","forwardHoursOnly","forEach","result","start","end","customChrono","Chrono","options","casualOption","parsers","push","refiners","phrase","parse","p","freeze","Symbol","TimeParser","this","normaliseTimes","dates","length","time","map","date","extractedText","beforeText","substr","afterText","test","slice","processedText","PATTERNS","UsersParser","users","patterns","some","exec","_this","parseUsers","recipients","string","split","listBreaker","user","filter","ActionParser","action","normalise","parseNoDates","parseMultipleDates","punctuation","error","DEFAULT_LOCALE","ReminderConfirmation","locale","TwitterCldr","listFormatter","a","join","set_data","TwitterCldrDataBundle","ListFormatter","confirm","reminder","template","getLocalised","data","formatUser","formatAction","formatTime","placeholder","prop","formattedUsers","format","formattedAction","PATTERN1","PATTERN2","PATTERN3","PATTERN4","due","isToday","formatHoursAndMinutes","isTomorrow","isThisMonth","today","startOf","tomorrow","add","isBetween","in2days","thisMonth","nextMonth","minute","nextHour","ReminderRefiner","reminderConfirmation","hasTime","hasUsers","hasAction","startsWith","confirmation","intent","QueryConfirmation","QueryRefiner","hasNoActions","queryConfirmation","bind","IntentParser","cleaners","global","Function","intentParser","String","cleaningPromises","cleaner","parsingPromises","parser","refiningPromises","refiner","reject","then","reduce","val"],"mappings":"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"}